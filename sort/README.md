# Sort

## Bubble Sort

연속된 두 개의 인덱스 값을 비교하여 정한 기준 값을 뒤로 넘기는 과정을 반복하여 정렬하는 방법
1바퀴 돌 때 정한 기준 값이 가장 마지막으로 가지고 그 다음 바퀴에서는 정렬된 마지막 값 전까지 비교한다.
버블소트의 경우 기존의 순서가 정렬에 의해 수정되지 않는 안정 정렬이다.
시간복잡도: O(N^2)

## Selection Sort

현재 위치에 들어가게 될 값을 찾아 넣어 정렬하는 방법
i번째 위치에 들어오게 될 값을 i+1부터 마지막까지 비교한 후 정한 기준 값을 i 인덱스의 값과 교환해준다.
선택정렬의 경우 기존의 순서가 정렬에 의해 수정되는 불안정 정렬이다.
시간복잡도: O(N^2)

## Insertion Sort

i번째 값을 처음부터 i-1번째까지 중 들어갈 위치에 삽입하는 것을 통해 정렬하는 방법
삽입정렬의 경우 기존의 순서가 정렬에 의해 수정되지 않는 안정 정렬이다.
시간복잡도의 경우 이미 정렬된 경우 한번씩만 체크하기 때문에 O(N)이지만 최악인 O(N^2)을 시간복잡도로 갖는다.

## Merge Sort

리스트를 절반으로 나누어 두 개의 리스트로 만드는 과정을 계속 반복한다. 리스트가 더 이상 나눌 수 없을 때 두 개의 리스트를 정렬된 하나의 리스트로 합치는 계속 진행하여 최종적으로 전체 크기의 정렬된 리스트 하나를 만들어낸다.
분할 정복의 경우 기존의 순서가 정렬에 의해 수정되지 않는 안정 정렬이다.
시간복잡도의 경우 O(NlogN)이다. (두개의 리스트로 나누는 과정 logN, 합치면서 정렬하는 과정 N)

## Quick Sort

Merge sort처럼 분할정복을 통한 정렬 알고리즘이다. 기준이 되는 pivot을 정하고 pivot에 해당하는 값보다 작은 값은 pivot 왼쪽으로 아닌 값을 오른쪽으로 이동시킨다. pivot을 기준으로 나뉘어진 두 리스트에 대해 똑같은 과정을 반복한다.
퀵 정렬의 경우 기존의 순서가 정렬에 의해 수정되는 불안정 정렬이다.
시간복잡도의 경우 평균적으로 O(NlogN)의 속도이지만 최악의 경우 (pivot으로 나눌 때 계속 불균형하게 나누는 경우) O(N^2)의 속도를 갖는다.